
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tcodes0/go/cmd/copyright/main.go (53.3%)</option>
				
				<option value="file1">github.com/tcodes0/go/cmd/copyright/mock_file.go (42.4%)</option>
				
				<option value="file2">github.com/tcodes0/go/cmd/copyright/mock_os_files.go (63.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >// Copyright 2024 Raphael Thomazella. All rights reserved.
// Use of this source code is governed by the BSD-3-Clause
// license that can be found in the LICENSE file and online
// at https://opensource.org/license/BSD-3-clause.

package main

import (
        "context"
        _ "embed"
        "errors"
        "flag"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/tcodes0/go/logging"
        "github.com/tcodes0/go/misc"
)

//go:embed header.txt
var licenseHeader string

const (
        golang int = iota + 1
        shell
)

type glob string

func (glob glob) String() string <span class="cov10" title="9">{
        return string(glob)
}</span>

func (glob glob) CommentToken() string <span class="cov6" title="4">{
        switch glob.Kind() </span>{
        default:<span class="cov0" title="0">
                return ""</span>
        case golang:<span class="cov5" title="3">
                return "// "</span>
        case shell:<span class="cov1" title="1">
                return "# "</span>
        }
}

func (glob glob) Kind() int <span class="cov8" title="7">{
        if strings.HasSuffix(glob.String(), ".go") </span><span class="cov7" title="5">{
                return golang
        }</span>

        <span class="cov3" title="2">if strings.HasSuffix(glob.String(), ".sh") </span><span class="cov3" title="2">{
                return shell
        }</span>

        <span class="cov0" title="0">return 0</span>
}

type File interface {
        io.ReadCloser
        WriteString(s string) (n int, err error)
}

type OSFiles interface {
        Glob(pattern string) (matches []string, err error)
        OpenFile(name string, flag int, perm os.FileMode) (file File, err error)
        Open(name string) (file File, err error)
        ReadAll(r io.Reader) (b []byte, err error)
}

type osFiles struct{}

var _ OSFiles = (*osFiles)(nil)

func (osf osFiles) Glob(pattern string) (matches []string, err error) <span class="cov0" title="0">{
        //nolint:wrapcheck // test
        return filepath.Glob(pattern)
}</span>

func (osf osFiles) OpenFile(name string, flags int, perm os.FileMode) (file File, err error) <span class="cov0" title="0">{
        //nolint:wrapcheck // test
        return os.OpenFile(name, flags, perm)
}</span>

func (osf osFiles) Open(name string) (file File, err error) <span class="cov0" title="0">{
        //nolint:wrapcheck // test
        return os.Open(name)
}</span>

func (osf osFiles) ReadAll(r io.Reader) (b []byte, err error) <span class="cov0" title="0">{
        //nolint:wrapcheck // test
        return io.ReadAll(r)
}</span>

func main() <span class="cov0" title="0">{
        flagset := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
        fLogLevel := flagset.Int("log-level", int(logging.LInfo), "control logging output; 1 is debug, 5 is fatal")
        fColor := flagset.Bool("color", false, "colored logging output. default false")
        fGlobs := flagset.String("globs", "", "comma-space separated list of globs to search for files. Default empty. required")
        fIgnore := flagset.String("ignore", "", "comma-space separated list of regexes to exclude files by path match. Default empty")
        fDryrun := flagset.Bool("dryrun", false, "do not modify files, only log what would be done. Default false")

        err := flagset.Parse(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("ERR: failed to parse flags: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *fGlobs == "" </span><span class="cov0" title="0">{
                flagset.Usage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">opts := []logging.CreateOptions{logging.OptFlags(log.Lshortfile), logging.OptLevel(logging.Level(*fLogLevel))}
        if *fColor </span><span class="cov0" title="0">{
                opts = append(opts, logging.OptColor())
        }</span>

        <span class="cov0" title="0">logger := logging.Create(opts...)
        globs := strings.Split(*fGlobs, ", ")
        rawRegexps := strings.Split(*fIgnore, ", ")

        if globs == nil </span><span class="cov0" title="0">{
                logger.Debug().Log("no globs provided")

                return
        }</span>

        <span class="cov0" title="0">ignores := make([]*regexp.Regexp, 0, len(rawRegexps))

        for _, raw := range rawRegexps </span><span class="cov0" title="0">{
                var reg *regexp.Regexp

                if raw == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">reg, err = regexp.Compile(raw)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to compile regexp %s: %v", raw, err)
                }</span>

                <span class="cov0" title="0">ignores = append(ignores, reg)</span>
        }

        <span class="cov0" title="0">err = boilerplate(*logger, osFiles{}, globs, ignores, licenseHeader, *fDryrun)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("failed: %v", err)
        }</span>
}

func boilerplate(
        logger logging.Logger,
        osf OSFiles,
        globs []string,
        ignoreRegexps []*regexp.Regexp,
        header string,
        dryrun bool,
) error <span class="cov6" title="4">{
        for _, fileglob := range globs </span><span class="cov8" title="6">{
                filePaths, err := osf.Glob(fileglob)
                if err != nil </span><span class="cov0" title="0">{
                        return misc.Wrap(err, "failed to glob files")
                }</span>

                <span class="cov8" title="6">logger.Debug().Logf("glob: '%s', count %d, files: %s", fileglob, len(filePaths), filePaths)

                if len(filePaths) == 0 </span><span class="cov1" title="1">{
                        logger.Warn().Logf("no files matched: %s", fileglob)

                        continue</span>
                }

                <span class="cov7" title="5">headerWithComments := ""

        matchesLoop:
                for _, filePath := range filePaths </span><span class="cov7" title="5">{
                        for _, regexp := range ignoreRegexps </span><span class="cov3" title="2">{
                                if regexp.MatchString(filePath) </span><span class="cov1" title="1">{
                                        logger.Debug().Logf("skipping %s because ignore '%s' matches", filePath, regexp.String())

                                        continue matchesLoop</span>
                                }
                        }

                        <span class="cov6" title="4">if headerWithComments == "" </span><span class="cov6" title="4">{
                                headerWithComments = addComments(header, glob(fileglob))
                        }</span>

                        <span class="cov6" title="4">err, processed := processFile(logger, osf, filePath, fileglob, headerWithComments, dryrun)
                        if err != nil &amp;&amp; !errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                                return misc.Wrapf(err, "failed: %s", filePath)
                        }</span>

                        <span class="cov6" title="4">if processed </span><span class="cov5" title="3">{
                                logger.Log(filePath)
                        }</span>
                }
        }

        <span class="cov6" title="4">return nil</span>
}

func processFile(
        logger logging.Logger,
        osf OSFiles,
        path,
        fileGlob,
        header string,
        dryrun bool,
) (err error, processed bool) <span class="cov6" title="4">{
        hasHeader, content, err := checkForHeader(osf, path, header)
        if err != nil </span><span class="cov0" title="0">{
                return misc.Wrap(err, "failed to check for header"), false
        }</span>

        <span class="cov6" title="4">if hasHeader </span><span class="cov1" title="1">{
                logger.Debug().Logf("header already applied: %s", path)

                return nil, false
        }</span>

        <span class="cov5" title="3">if !dryrun </span><span class="cov5" title="3">{
                err = applyHeader(osf, header, path, content, glob(fileGlob))
                if err != nil </span><span class="cov0" title="0">{
                        return misc.Wrap(err, "failed to apply header"), false
                }</span>
        }

        <span class="cov5" title="3">return nil, true</span>
}

func checkForHeader(osf OSFiles, path, header string) (hasHeader bool, content string, err error) <span class="cov6" title="4">{
        file, err := osf.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", misc.Wrap(err, "failed to open file")
        }</span>

        <span class="cov6" title="4">defer file.Close()

        b, err := osf.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", misc.Wrap(err, "failed to read file")
        }</span>

        <span class="cov6" title="4">content = string(b)

        return strings.Contains(content, header), content, nil</span>
}

func addComments(license string, fileGlob glob) (commentedLicense string) <span class="cov6" title="4">{
        for _, licenseLine := range strings.Split(license, "\n") </span><span class="cov6" title="4">{
                commentedLicense += fileGlob.CommentToken() + licenseLine + "\n"
        }</span>

        <span class="cov6" title="4">return commentedLicense</span>
}

func applyHeader(osf OSFiles, header, path, content string, glob glob) error <span class="cov5" title="3">{
        file, err := osf.OpenFile(path, os.O_RDWR|os.O_TRUNC, 0)
        if err != nil </span><span class="cov0" title="0">{
                return misc.Wrap(err, "unable to open file")
        }</span>

        <span class="cov5" title="3">defer file.Close()

        switch glob.Kind() </span>{
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown kind %d", glob.Kind())</span>
        case golang:<span class="cov3" title="2">
                _, err = file.WriteString(header + "\n" + content)</span>
        case shell:<span class="cov1" title="1">
                shebang, rest, found := strings.Cut(content, "\n")
                if !found </span><span class="cov0" title="0">{
                        return misc.Wrapf(err, "unable to parse %s", path)
                }</span> else<span class="cov1" title="1"> {
                        _, err = file.WriteString(shebang + "\n" + header + rest)
                }</span>
        }

        <span class="cov5" title="3">if err != nil </span><span class="cov0" title="0">{
                return misc.Wrap(err, "unable to write to file")
        }</span>

        <span class="cov5" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by mockery v2.43.0. DO NOT EDIT.

package main

import mock "github.com/stretchr/testify/mock"

// MockFile is an autogenerated mock type for the File type
type MockFile struct {
        mock.Mock
}

type MockFile_Expecter struct {
        mock *mock.Mock
}

func (_m *MockFile) Expect() *MockFile_Expecter <span class="cov10" title="10">{
        return &amp;MockFile_Expecter{mock: &amp;_m.Mock}
}</span>

// Close provides a mock function with given fields:
func (_m *MockFile) Close() error <span class="cov8" title="7">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Close")</span>
        }

        <span class="cov8" title="7">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov8" title="7"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="7">return r0</span>
}

// MockFile_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockFile_Close_Call struct {
        *mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockFile_Expecter) Close() *MockFile_Close_Call <span class="cov8" title="7">{
        return &amp;MockFile_Close_Call{Call: _e.mock.On("Close")}
}</span>

func (_c *MockFile_Close_Call) Run(run func()) *MockFile_Close_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockFile_Close_Call) Return(_a0 error) *MockFile_Close_Call <span class="cov8" title="7">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockFile_Close_Call) RunAndReturn(run func() error) *MockFile_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Read provides a mock function with given fields: p
func (_m *MockFile) Read(p []byte) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(p)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Read")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func([]byte) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(p)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func([]byte) int); ok </span><span class="cov0" title="0">{
                r0 = rf(p)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func([]byte) error); ok </span><span class="cov0" title="0">{
                r1 = rf(p)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockFile_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockFile_Read_Call struct {
        *mock.Call
}

// Read is a helper method to define mock.On call
//   - p []byte
func (_e *MockFile_Expecter) Read(p interface{}) *MockFile_Read_Call <span class="cov0" title="0">{
        return &amp;MockFile_Read_Call{Call: _e.mock.On("Read", p)}
}</span>

func (_c *MockFile_Read_Call) Run(run func(p []byte)) *MockFile_Read_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]byte))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockFile_Read_Call) Return(n int, err error) *MockFile_Read_Call <span class="cov0" title="0">{
        _c.Call.Return(n, err)
        return _c
}</span>

func (_c *MockFile_Read_Call) RunAndReturn(run func([]byte) (int, error)) *MockFile_Read_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WriteString provides a mock function with given fields: s
func (_m *MockFile) WriteString(s string) (int, error) <span class="cov5" title="3">{
        ret := _m.Called(s)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WriteString")</span>
        }

        <span class="cov5" title="3">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(s)
        }</span>
        <span class="cov5" title="3">if rf, ok := ret.Get(0).(func(string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(s)
        }</span> else<span class="cov5" title="3"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov5" title="3">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(s)
        }</span> else<span class="cov5" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="3">return r0, r1</span>
}

// MockFile_WriteString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteString'
type MockFile_WriteString_Call struct {
        *mock.Call
}

// WriteString is a helper method to define mock.On call
//   - s string
func (_e *MockFile_Expecter) WriteString(s interface{}) *MockFile_WriteString_Call <span class="cov5" title="3">{
        return &amp;MockFile_WriteString_Call{Call: _e.mock.On("WriteString", s)}
}</span>

func (_c *MockFile_WriteString_Call) Run(run func(s string)) *MockFile_WriteString_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockFile_WriteString_Call) Return(n int, err error) *MockFile_WriteString_Call <span class="cov5" title="3">{
        _c.Call.Return(n, err)
        return _c
}</span>

func (_c *MockFile_WriteString_Call) RunAndReturn(run func(string) (int, error)) *MockFile_WriteString_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockFile creates a new instance of MockFile. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFile(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockFile <span class="cov7" title="5">{
        mock := &amp;MockFile{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov7" title="5">{ mock.AssertExpectations(t) }</span>)

        <span class="cov7" title="5">return mock</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by mockery v2.43.0. DO NOT EDIT.

package main

import (
        io "io"
        fs "io/fs"

        mock "github.com/stretchr/testify/mock"
)

// MockOSFiles is an autogenerated mock type for the OSFiles type
type MockOSFiles struct {
        mock.Mock
}

type MockOSFiles_Expecter struct {
        mock *mock.Mock
}

func (_m *MockOSFiles) Expect() *MockOSFiles_Expecter <span class="cov10" title="17">{
        return &amp;MockOSFiles_Expecter{mock: &amp;_m.Mock}
}</span>

// Glob provides a mock function with given fields: pattern
func (_m *MockOSFiles) Glob(pattern string) ([]string, error) <span class="cov6" title="6">{
        ret := _m.Called(pattern)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Glob")</span>
        }

        <span class="cov6" title="6">var r0 []string
        var r1 error
        if rf, ok := ret.Get(0).(func(string) ([]string, error)); ok </span><span class="cov0" title="0">{
                return rf(pattern)
        }</span>
        <span class="cov6" title="6">if rf, ok := ret.Get(0).(func(string) []string); ok </span><span class="cov0" title="0">{
                r0 = rf(pattern)
        }</span> else<span class="cov6" title="6"> {
                if ret.Get(0) != nil </span><span class="cov6" title="6">{
                        r0 = ret.Get(0).([]string)
                }</span>
        }

        <span class="cov6" title="6">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(pattern)
        }</span> else<span class="cov6" title="6"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov6" title="6">return r0, r1</span>
}

// MockOSFiles_Glob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Glob'
type MockOSFiles_Glob_Call struct {
        *mock.Call
}

// Glob is a helper method to define mock.On call
//   - pattern string
func (_e *MockOSFiles_Expecter) Glob(pattern interface{}) *MockOSFiles_Glob_Call <span class="cov6" title="6">{
        return &amp;MockOSFiles_Glob_Call{Call: _e.mock.On("Glob", pattern)}
}</span>

func (_c *MockOSFiles_Glob_Call) Run(run func(pattern string)) *MockOSFiles_Glob_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOSFiles_Glob_Call) Return(matches []string, err error) *MockOSFiles_Glob_Call <span class="cov6" title="6">{
        _c.Call.Return(matches, err)
        return _c
}</span>

func (_c *MockOSFiles_Glob_Call) RunAndReturn(run func(string) ([]string, error)) *MockOSFiles_Glob_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Open provides a mock function with given fields: name
func (_m *MockOSFiles) Open(name string) (File, error) <span class="cov5" title="4">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Open")</span>
        }

        <span class="cov5" title="4">var r0 File
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (File, error)); ok </span><span class="cov0" title="0">{
                return rf(name)
        }</span>
        <span class="cov5" title="4">if rf, ok := ret.Get(0).(func(string) File); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov5" title="4"> {
                if ret.Get(0) != nil </span><span class="cov5" title="4">{
                        r0 = ret.Get(0).(File)
                }</span>
        }

        <span class="cov5" title="4">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(name)
        }</span> else<span class="cov5" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="4">return r0, r1</span>
}

// MockOSFiles_Open_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Open'
type MockOSFiles_Open_Call struct {
        *mock.Call
}

// Open is a helper method to define mock.On call
//   - name string
func (_e *MockOSFiles_Expecter) Open(name interface{}) *MockOSFiles_Open_Call <span class="cov5" title="4">{
        return &amp;MockOSFiles_Open_Call{Call: _e.mock.On("Open", name)}
}</span>

func (_c *MockOSFiles_Open_Call) Run(run func(name string)) *MockOSFiles_Open_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOSFiles_Open_Call) Return(file File, err error) *MockOSFiles_Open_Call <span class="cov5" title="4">{
        _c.Call.Return(file, err)
        return _c
}</span>

func (_c *MockOSFiles_Open_Call) RunAndReturn(run func(string) (File, error)) *MockOSFiles_Open_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// OpenFile provides a mock function with given fields: name, flag, perm
func (_m *MockOSFiles) OpenFile(name string, flag int, perm fs.FileMode) (File, error) <span class="cov4" title="3">{
        ret := _m.Called(name, flag, perm)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for OpenFile")</span>
        }

        <span class="cov4" title="3">var r0 File
        var r1 error
        if rf, ok := ret.Get(0).(func(string, int, fs.FileMode) (File, error)); ok </span><span class="cov0" title="0">{
                return rf(name, flag, perm)
        }</span>
        <span class="cov4" title="3">if rf, ok := ret.Get(0).(func(string, int, fs.FileMode) File); ok </span><span class="cov0" title="0">{
                r0 = rf(name, flag, perm)
        }</span> else<span class="cov4" title="3"> {
                if ret.Get(0) != nil </span><span class="cov4" title="3">{
                        r0 = ret.Get(0).(File)
                }</span>
        }

        <span class="cov4" title="3">if rf, ok := ret.Get(1).(func(string, int, fs.FileMode) error); ok </span><span class="cov0" title="0">{
                r1 = rf(name, flag, perm)
        }</span> else<span class="cov4" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="3">return r0, r1</span>
}

// MockOSFiles_OpenFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenFile'
type MockOSFiles_OpenFile_Call struct {
        *mock.Call
}

// OpenFile is a helper method to define mock.On call
//   - name string
//   - flag int
//   - perm fs.FileMode
func (_e *MockOSFiles_Expecter) OpenFile(name interface{}, flag interface{}, perm interface{}) *MockOSFiles_OpenFile_Call <span class="cov4" title="3">{
        return &amp;MockOSFiles_OpenFile_Call{Call: _e.mock.On("OpenFile", name, flag, perm)}
}</span>

func (_c *MockOSFiles_OpenFile_Call) Run(run func(name string, flag int, perm fs.FileMode)) *MockOSFiles_OpenFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(int), args[2].(fs.FileMode))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOSFiles_OpenFile_Call) Return(file File, err error) *MockOSFiles_OpenFile_Call <span class="cov4" title="3">{
        _c.Call.Return(file, err)
        return _c
}</span>

func (_c *MockOSFiles_OpenFile_Call) RunAndReturn(run func(string, int, fs.FileMode) (File, error)) *MockOSFiles_OpenFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ReadAll provides a mock function with given fields: r
func (_m *MockOSFiles) ReadAll(r io.Reader) ([]byte, error) <span class="cov5" title="4">{
        ret := _m.Called(r)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ReadAll")</span>
        }

        <span class="cov5" title="4">var r0 []byte
        var r1 error
        if rf, ok := ret.Get(0).(func(io.Reader) ([]byte, error)); ok </span><span class="cov0" title="0">{
                return rf(r)
        }</span>
        <span class="cov5" title="4">if rf, ok := ret.Get(0).(func(io.Reader) []byte); ok </span><span class="cov0" title="0">{
                r0 = rf(r)
        }</span> else<span class="cov5" title="4"> {
                if ret.Get(0) != nil </span><span class="cov5" title="4">{
                        r0 = ret.Get(0).([]byte)
                }</span>
        }

        <span class="cov5" title="4">if rf, ok := ret.Get(1).(func(io.Reader) error); ok </span><span class="cov0" title="0">{
                r1 = rf(r)
        }</span> else<span class="cov5" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="4">return r0, r1</span>
}

// MockOSFiles_ReadAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAll'
type MockOSFiles_ReadAll_Call struct {
        *mock.Call
}

// ReadAll is a helper method to define mock.On call
//   - r io.Reader
func (_e *MockOSFiles_Expecter) ReadAll(r interface{}) *MockOSFiles_ReadAll_Call <span class="cov5" title="4">{
        return &amp;MockOSFiles_ReadAll_Call{Call: _e.mock.On("ReadAll", r)}
}</span>

func (_c *MockOSFiles_ReadAll_Call) Run(run func(r io.Reader)) *MockOSFiles_ReadAll_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(io.Reader))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOSFiles_ReadAll_Call) Return(b []byte, err error) *MockOSFiles_ReadAll_Call <span class="cov5" title="4">{
        _c.Call.Return(b, err)
        return _c
}</span>

func (_c *MockOSFiles_ReadAll_Call) RunAndReturn(run func(io.Reader) ([]byte, error)) *MockOSFiles_ReadAll_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockOSFiles creates a new instance of MockOSFiles. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOSFiles(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockOSFiles <span class="cov5" title="4">{
        mock := &amp;MockOSFiles{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov5" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov5" title="4">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
